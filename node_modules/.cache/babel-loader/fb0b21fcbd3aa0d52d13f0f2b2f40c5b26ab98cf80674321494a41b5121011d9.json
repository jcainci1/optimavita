{"ast":null,"code":"import _objectSpread from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectDestructuringEmpty from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js\";\nimport _classCallCheck from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classPrivateMethodInitSpec from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _executeFetch, _updateStaleTimeout, _computeRefetchInterval, _updateRefetchInterval, _updateTimers, _clearStaleTimeout, _clearRefetchInterval, _updateQuery, _notify;\n// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, isValidTimeout, noop, replaceData, resolveEnabled, resolveStaleTime, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nvar QueryObserver = (_client = /*#__PURE__*/new WeakMap(), _currentQuery = /*#__PURE__*/new WeakMap(), _currentQueryInitialState = /*#__PURE__*/new WeakMap(), _currentResult = /*#__PURE__*/new WeakMap(), _currentResultState = /*#__PURE__*/new WeakMap(), _currentResultOptions = /*#__PURE__*/new WeakMap(), _currentThenable = /*#__PURE__*/new WeakMap(), _selectError = /*#__PURE__*/new WeakMap(), _selectFn = /*#__PURE__*/new WeakMap(), _selectResult = /*#__PURE__*/new WeakMap(), _lastQueryWithDefinedData = /*#__PURE__*/new WeakMap(), _staleTimeoutId = /*#__PURE__*/new WeakMap(), _refetchIntervalId = /*#__PURE__*/new WeakMap(), _currentRefetchInterval = /*#__PURE__*/new WeakMap(), _trackedProps = /*#__PURE__*/new WeakMap(), _executeFetch = /*#__PURE__*/new WeakSet(), _updateStaleTimeout = /*#__PURE__*/new WeakSet(), _computeRefetchInterval = /*#__PURE__*/new WeakSet(), _updateRefetchInterval = /*#__PURE__*/new WeakSet(), _updateTimers = /*#__PURE__*/new WeakSet(), _clearStaleTimeout = /*#__PURE__*/new WeakSet(), _clearRefetchInterval = /*#__PURE__*/new WeakSet(), _updateQuery = /*#__PURE__*/new WeakSet(), _notify = /*#__PURE__*/new WeakSet(), /*#__PURE__*/function (_Subscribable) {\n  _inherits(QueryObserver, _Subscribable);\n  var _super = _createSuper(QueryObserver);\n  function QueryObserver(client, options) {\n    var _this;\n    _classCallCheck(this, QueryObserver);\n    _this = _super.call(this);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _notify);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateQuery);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _clearRefetchInterval);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _clearStaleTimeout);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateTimers);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateRefetchInterval);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _computeRefetchInterval);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateStaleTimeout);\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _executeFetch);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _client, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentQuery, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentQueryInitialState, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentResult, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentResultState, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentResultOptions, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentThenable, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _selectError, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _selectFn, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _selectResult, {\n      writable: true,\n      value: void 0\n    });\n    // This property keeps track of the last query with defined data.\n    // It will be used to pass the previous data and query to the placeholder function between renders.\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _lastQueryWithDefinedData, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _staleTimeoutId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _refetchIntervalId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentRefetchInterval, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _trackedProps, {\n      writable: true,\n      value: /* @__PURE__ */new Set()\n    });\n    _this.options = options;\n    _classPrivateFieldSet(_assertThisInitialized(_this), _client, client);\n    _classPrivateFieldSet(_assertThisInitialized(_this), _selectError, null);\n    _classPrivateFieldSet(_assertThisInitialized(_this), _currentThenable, pendingThenable());\n    if (!_this.options.experimental_prefetchInRender) {\n      _classPrivateFieldGet(_assertThisInitialized(_this), _currentThenable).reject(new Error(\"experimental_prefetchInRender feature flag is not enabled\"));\n    }\n    _this.bindMethods();\n    _this.setOptions(options);\n    return _this;\n  }\n  _createClass(QueryObserver, [{\n    key: \"bindMethods\",\n    value: function bindMethods() {\n      this.refetch = this.refetch.bind(this);\n    }\n  }, {\n    key: \"onSubscribe\",\n    value: function onSubscribe() {\n      if (this.listeners.size === 1) {\n        _classPrivateFieldGet(this, _currentQuery).addObserver(this);\n        if (shouldFetchOnMount(_classPrivateFieldGet(this, _currentQuery), this.options)) {\n          _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n        } else {\n          this.updateResult();\n        }\n        _classPrivateMethodGet(this, _updateTimers, _updateTimers2).call(this);\n      }\n    }\n  }, {\n    key: \"onUnsubscribe\",\n    value: function onUnsubscribe() {\n      if (!this.hasListeners()) {\n        this.destroy();\n      }\n    }\n  }, {\n    key: \"shouldFetchOnReconnect\",\n    value: function shouldFetchOnReconnect() {\n      return shouldFetchOn(_classPrivateFieldGet(this, _currentQuery), this.options, this.options.refetchOnReconnect);\n    }\n  }, {\n    key: \"shouldFetchOnWindowFocus\",\n    value: function shouldFetchOnWindowFocus() {\n      return shouldFetchOn(_classPrivateFieldGet(this, _currentQuery), this.options, this.options.refetchOnWindowFocus);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.listeners = /* @__PURE__ */new Set();\n      _classPrivateMethodGet(this, _clearStaleTimeout, _clearStaleTimeout2).call(this);\n      _classPrivateMethodGet(this, _clearRefetchInterval, _clearRefetchInterval2).call(this);\n      _classPrivateFieldGet(this, _currentQuery).removeObserver(this);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, notifyOptions) {\n      var prevOptions = this.options;\n      var prevQuery = _classPrivateFieldGet(this, _currentQuery);\n      this.options = _classPrivateFieldGet(this, _client).defaultQueryOptions(options);\n      if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) !== \"boolean\") {\n        throw new Error(\"Expected enabled to be a boolean or a callback that returns a boolean\");\n      }\n      _classPrivateMethodGet(this, _updateQuery, _updateQuery2).call(this);\n      _classPrivateFieldGet(this, _currentQuery).setOptions(this.options);\n      if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n        _classPrivateFieldGet(this, _client).getQueryCache().notify({\n          type: \"observerOptionsUpdated\",\n          query: _classPrivateFieldGet(this, _currentQuery),\n          observer: this\n        });\n      }\n      var mounted = this.hasListeners();\n      if (mounted && shouldFetchOptionally(_classPrivateFieldGet(this, _currentQuery), prevQuery, this.options, prevOptions)) {\n        _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n      }\n      this.updateResult(notifyOptions);\n      if (mounted && (_classPrivateFieldGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, _classPrivateFieldGet(this, _currentQuery)))) {\n        _classPrivateMethodGet(this, _updateStaleTimeout, _updateStaleTimeout2).call(this);\n      }\n      var nextRefetchInterval = _classPrivateMethodGet(this, _computeRefetchInterval, _computeRefetchInterval2).call(this);\n      if (mounted && (_classPrivateFieldGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(this, _currentQuery)) || nextRefetchInterval !== _classPrivateFieldGet(this, _currentRefetchInterval))) {\n        _classPrivateMethodGet(this, _updateRefetchInterval, _updateRefetchInterval2).call(this, nextRefetchInterval);\n      }\n    }\n  }, {\n    key: \"getOptimisticResult\",\n    value: function getOptimisticResult(options) {\n      var query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), options);\n      var result = this.createResult(query, options);\n      if (shouldAssignObserverCurrentProperties(this, result)) {\n        _classPrivateFieldSet(this, _currentResult, result);\n        _classPrivateFieldSet(this, _currentResultOptions, this.options);\n        _classPrivateFieldSet(this, _currentResultState, _classPrivateFieldGet(this, _currentQuery).state);\n      }\n      return result;\n    }\n  }, {\n    key: \"getCurrentResult\",\n    value: function getCurrentResult() {\n      return _classPrivateFieldGet(this, _currentResult);\n    }\n  }, {\n    key: \"trackResult\",\n    value: function trackResult(result, onPropTracked) {\n      var _this2 = this;\n      var trackedResult = {};\n      Object.keys(result).forEach(function (key) {\n        Object.defineProperty(trackedResult, key, {\n          configurable: false,\n          enumerable: true,\n          get: function get() {\n            _this2.trackProp(key);\n            onPropTracked === null || onPropTracked === void 0 || onPropTracked(key);\n            return result[key];\n          }\n        });\n      });\n      return trackedResult;\n    }\n  }, {\n    key: \"trackProp\",\n    value: function trackProp(key) {\n      _classPrivateFieldGet(this, _trackedProps).add(key);\n    }\n  }, {\n    key: \"getCurrentQuery\",\n    value: function getCurrentQuery() {\n      return _classPrivateFieldGet(this, _currentQuery);\n    }\n  }, {\n    key: \"refetch\",\n    value: function refetch() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        options = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));\n      return this.fetch(_objectSpread({}, options));\n    }\n  }, {\n    key: \"fetchOptimistic\",\n    value: function fetchOptimistic(options) {\n      var _this3 = this;\n      var defaultedOptions = _classPrivateFieldGet(this, _client).defaultQueryOptions(options);\n      var query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), defaultedOptions);\n      return query.fetch().then(function () {\n        return _this3.createResult(query, defaultedOptions);\n      });\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(fetchOptions) {\n      var _fetchOptions$cancelR,\n        _this4 = this;\n      return _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this, _objectSpread(_objectSpread({}, fetchOptions), {}, {\n        cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) !== null && _fetchOptions$cancelR !== void 0 ? _fetchOptions$cancelR : true\n      })).then(function () {\n        _this4.updateResult();\n        return _classPrivateFieldGet(_this4, _currentResult);\n      });\n    }\n  }, {\n    key: \"createResult\",\n    value: function createResult(query, options) {\n      var _this5 = this;\n      var prevQuery = _classPrivateFieldGet(this, _currentQuery);\n      var prevOptions = this.options;\n      var prevResult = _classPrivateFieldGet(this, _currentResult);\n      var prevResultState = _classPrivateFieldGet(this, _currentResultState);\n      var prevResultOptions = _classPrivateFieldGet(this, _currentResultOptions);\n      var queryChange = query !== prevQuery;\n      var queryInitialState = queryChange ? query.state : _classPrivateFieldGet(this, _currentQueryInitialState);\n      var state = query.state;\n      var newState = _objectSpread({}, state);\n      var isPlaceholderData = false;\n      var data;\n      if (options._optimisticResults) {\n        var mounted = this.hasListeners();\n        var fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n        var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n        if (fetchOnMount || fetchOptionally) {\n          newState = _objectSpread(_objectSpread({}, newState), fetchState(state.data, query.options));\n        }\n        if (options._optimisticResults === \"isRestoring\") {\n          newState.fetchStatus = \"idle\";\n        }\n      }\n      var _newState = newState,\n        error = _newState.error,\n        errorUpdatedAt = _newState.errorUpdatedAt,\n        status = _newState.status;\n      if (options.select && newState.data !== void 0) {\n        if (prevResult && newState.data === (prevResultState === null || prevResultState === void 0 ? void 0 : prevResultState.data) && options.select === _classPrivateFieldGet(this, _selectFn)) {\n          data = _classPrivateFieldGet(this, _selectResult);\n        } else {\n          try {\n            _classPrivateFieldSet(this, _selectFn, options.select);\n            data = options.select(newState.data);\n            data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, data, options);\n            _classPrivateFieldSet(this, _selectResult, data);\n            _classPrivateFieldSet(this, _selectError, null);\n          } catch (selectError) {\n            _classPrivateFieldSet(this, _selectError, selectError);\n          }\n        }\n      } else {\n        data = newState.data;\n      }\n      if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n        var placeholderData;\n        if (prevResult !== null && prevResult !== void 0 && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions === null || prevResultOptions === void 0 ? void 0 : prevResultOptions.placeholderData)) {\n          placeholderData = prevResult.data;\n        } else {\n          var _classPrivateFieldGet2;\n          placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData((_classPrivateFieldGet2 = _classPrivateFieldGet(this, _lastQueryWithDefinedData)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.state.data, _classPrivateFieldGet(this, _lastQueryWithDefinedData)) : options.placeholderData;\n          if (options.select && placeholderData !== void 0) {\n            try {\n              placeholderData = options.select(placeholderData);\n              _classPrivateFieldSet(this, _selectError, null);\n            } catch (selectError) {\n              _classPrivateFieldSet(this, _selectError, selectError);\n            }\n          }\n        }\n        if (placeholderData !== void 0) {\n          status = \"success\";\n          data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, placeholderData, options);\n          isPlaceholderData = true;\n        }\n      }\n      if (_classPrivateFieldGet(this, _selectError)) {\n        error = _classPrivateFieldGet(this, _selectError);\n        data = _classPrivateFieldGet(this, _selectResult);\n        errorUpdatedAt = Date.now();\n        status = \"error\";\n      }\n      var isFetching = newState.fetchStatus === \"fetching\";\n      var isPending = status === \"pending\";\n      var isError = status === \"error\";\n      var isLoading = isPending && isFetching;\n      var hasData = data !== void 0;\n      var result = {\n        status: status,\n        fetchStatus: newState.fetchStatus,\n        isPending: isPending,\n        isSuccess: status === \"success\",\n        isError: isError,\n        isInitialLoading: isLoading,\n        isLoading: isLoading,\n        data: data,\n        dataUpdatedAt: newState.dataUpdatedAt,\n        error: error,\n        errorUpdatedAt: errorUpdatedAt,\n        failureCount: newState.fetchFailureCount,\n        failureReason: newState.fetchFailureReason,\n        errorUpdateCount: newState.errorUpdateCount,\n        isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n        isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n        isFetching: isFetching,\n        isRefetching: isFetching && !isPending,\n        isLoadingError: isError && !hasData,\n        isPaused: newState.fetchStatus === \"paused\",\n        isPlaceholderData: isPlaceholderData,\n        isRefetchError: isError && hasData,\n        isStale: isStale(query, options),\n        refetch: this.refetch,\n        promise: _classPrivateFieldGet(this, _currentThenable)\n      };\n      var nextResult = result;\n      if (this.options.experimental_prefetchInRender) {\n        var finalizeThenableIfPossible = function finalizeThenableIfPossible(thenable) {\n          if (nextResult.status === \"error\") {\n            thenable.reject(nextResult.error);\n          } else if (nextResult.data !== void 0) {\n            thenable.resolve(nextResult.data);\n          }\n        };\n        var recreateThenable = function recreateThenable() {\n          var pending = _classPrivateFieldSet(_this5, _currentThenable, nextResult.promise = pendingThenable());\n          finalizeThenableIfPossible(pending);\n        };\n        var prevThenable = _classPrivateFieldGet(this, _currentThenable);\n        switch (prevThenable.status) {\n          case \"pending\":\n            if (query.queryHash === prevQuery.queryHash) {\n              finalizeThenableIfPossible(prevThenable);\n            }\n            break;\n          case \"fulfilled\":\n            if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n              recreateThenable();\n            }\n            break;\n          case \"rejected\":\n            if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n              recreateThenable();\n            }\n            break;\n        }\n      }\n      return nextResult;\n    }\n  }, {\n    key: \"updateResult\",\n    value: function updateResult(notifyOptions) {\n      var _this6 = this;\n      var prevResult = _classPrivateFieldGet(this, _currentResult);\n      var nextResult = this.createResult(_classPrivateFieldGet(this, _currentQuery), this.options);\n      _classPrivateFieldSet(this, _currentResultState, _classPrivateFieldGet(this, _currentQuery).state);\n      _classPrivateFieldSet(this, _currentResultOptions, this.options);\n      if (_classPrivateFieldGet(this, _currentResultState).data !== void 0) {\n        _classPrivateFieldSet(this, _lastQueryWithDefinedData, _classPrivateFieldGet(this, _currentQuery));\n      }\n      if (shallowEqualObjects(nextResult, prevResult)) {\n        return;\n      }\n      _classPrivateFieldSet(this, _currentResult, nextResult);\n      var defaultNotifyOptions = {};\n      var shouldNotifyListeners = function shouldNotifyListeners() {\n        if (!prevResult) {\n          return true;\n        }\n        var notifyOnChangeProps = _this6.options.notifyOnChangeProps;\n        var notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n        if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !_classPrivateFieldGet(_this6, _trackedProps).size) {\n          return true;\n        }\n        var includedProps = new Set(notifyOnChangePropsValue !== null && notifyOnChangePropsValue !== void 0 ? notifyOnChangePropsValue : _classPrivateFieldGet(_this6, _trackedProps));\n        if (_this6.options.throwOnError) {\n          includedProps.add(\"error\");\n        }\n        return Object.keys(_classPrivateFieldGet(_this6, _currentResult)).some(function (key) {\n          var typedKey = key;\n          var changed = _classPrivateFieldGet(_this6, _currentResult)[typedKey] !== prevResult[typedKey];\n          return changed && includedProps.has(typedKey);\n        });\n      };\n      if ((notifyOptions === null || notifyOptions === void 0 ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n        defaultNotifyOptions.listeners = true;\n      }\n      _classPrivateMethodGet(this, _notify, _notify2).call(this, _objectSpread(_objectSpread({}, defaultNotifyOptions), notifyOptions));\n    }\n  }, {\n    key: \"onQueryUpdate\",\n    value: function onQueryUpdate() {\n      this.updateResult();\n      if (this.hasListeners()) {\n        _classPrivateMethodGet(this, _updateTimers, _updateTimers2).call(this);\n      }\n    }\n  }]);\n  return QueryObserver;\n}(Subscribable));\nfunction _executeFetch2(fetchOptions) {\n  _classPrivateMethodGet(this, _updateQuery, _updateQuery2).call(this);\n  var promise = _classPrivateFieldGet(this, _currentQuery).fetch(this.options, fetchOptions);\n  if (!(fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n  return promise;\n}\nfunction _updateStaleTimeout2() {\n  var _this7 = this;\n  _classPrivateMethodGet(this, _clearStaleTimeout, _clearStaleTimeout2).call(this);\n  var staleTime = resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(this, _currentQuery));\n  if (isServer || _classPrivateFieldGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {\n    return;\n  }\n  var time = timeUntilStale(_classPrivateFieldGet(this, _currentResult).dataUpdatedAt, staleTime);\n  var timeout = time + 1;\n  _classPrivateFieldSet(this, _staleTimeoutId, setTimeout(function () {\n    if (!_classPrivateFieldGet(_this7, _currentResult).isStale) {\n      _this7.updateResult();\n    }\n  }, timeout));\n}\nfunction _computeRefetchInterval2() {\n  var _ref2;\n  return (_ref2 = typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(_classPrivateFieldGet(this, _currentQuery)) : this.options.refetchInterval) !== null && _ref2 !== void 0 ? _ref2 : false;\n}\nfunction _updateRefetchInterval2(nextInterval) {\n  var _this8 = this;\n  _classPrivateMethodGet(this, _clearRefetchInterval, _clearRefetchInterval2).call(this);\n  _classPrivateFieldSet(this, _currentRefetchInterval, nextInterval);\n  if (isServer || resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) === false || !isValidTimeout(_classPrivateFieldGet(this, _currentRefetchInterval)) || _classPrivateFieldGet(this, _currentRefetchInterval) === 0) {\n    return;\n  }\n  _classPrivateFieldSet(this, _refetchIntervalId, setInterval(function () {\n    if (_this8.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      _classPrivateMethodGet(_this8, _executeFetch, _executeFetch2).call(_this8);\n    }\n  }, _classPrivateFieldGet(this, _currentRefetchInterval)));\n}\nfunction _updateTimers2() {\n  _classPrivateMethodGet(this, _updateStaleTimeout, _updateStaleTimeout2).call(this);\n  _classPrivateMethodGet(this, _updateRefetchInterval, _updateRefetchInterval2).call(this, _classPrivateMethodGet(this, _computeRefetchInterval, _computeRefetchInterval2).call(this));\n}\nfunction _clearStaleTimeout2() {\n  if (_classPrivateFieldGet(this, _staleTimeoutId)) {\n    clearTimeout(_classPrivateFieldGet(this, _staleTimeoutId));\n    _classPrivateFieldSet(this, _staleTimeoutId, void 0);\n  }\n}\nfunction _clearRefetchInterval2() {\n  if (_classPrivateFieldGet(this, _refetchIntervalId)) {\n    clearInterval(_classPrivateFieldGet(this, _refetchIntervalId));\n    _classPrivateFieldSet(this, _refetchIntervalId, void 0);\n  }\n}\nfunction _updateQuery2() {\n  var query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), this.options);\n  if (query === _classPrivateFieldGet(this, _currentQuery)) {\n    return;\n  }\n  var prevQuery = _classPrivateFieldGet(this, _currentQuery);\n  _classPrivateFieldSet(this, _currentQuery, query);\n  _classPrivateFieldSet(this, _currentQueryInitialState, query.state);\n  if (this.hasListeners()) {\n    prevQuery === null || prevQuery === void 0 || prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n}\nfunction _notify2(notifyOptions) {\n  var _this9 = this;\n  notifyManager.batch(function () {\n    if (notifyOptions.listeners) {\n      _this9.listeners.forEach(function (listener) {\n        listener(_classPrivateFieldGet(_this9, _currentResult));\n      });\n    }\n    _classPrivateFieldGet(_this9, _client).getQueryCache().notify({\n      query: _classPrivateFieldGet(_this9, _currentQuery),\n      type: \"observerResultsUpdated\"\n    });\n  });\n}\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    var value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport { QueryObserver };","map":{"version":3,"names":["focusManager","notifyManager","fetchState","Subscribable","pendingThenable","isServer","isValidTimeout","noop","replaceData","resolveEnabled","resolveStaleTime","shallowEqualObjects","timeUntilStale","QueryObserver","_client","WeakMap","_currentQuery","_currentQueryInitialState","_currentResult","_currentResultState","_currentResultOptions","_currentThenable","_selectError","_selectFn","_selectResult","_lastQueryWithDefinedData","_staleTimeoutId","_refetchIntervalId","_currentRefetchInterval","_trackedProps","_executeFetch","WeakSet","_updateStaleTimeout","_computeRefetchInterval","_updateRefetchInterval","_updateTimers","_clearStaleTimeout","_clearRefetchInterval","_updateQuery","_notify","_Subscribable","_inherits","_super","_createSuper","client","options","_this","_classCallCheck","call","_classPrivateMethodInitSpec","_assertThisInitialized","_classPrivateFieldInitSpec","writable","value","Set","_classPrivateFieldSet","experimental_prefetchInRender","_classPrivateFieldGet","reject","Error","bindMethods","setOptions","_createClass","key","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","_classPrivateMethodGet","_executeFetch2","updateResult","_updateTimers2","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","_clearStaleTimeout2","_clearRefetchInterval2","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","enabled","_updateQuery2","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","_updateStaleTimeout2","nextRefetchInterval","_computeRefetchInterval2","_updateRefetchInterval2","getOptimisticResult","build","result","createResult","shouldAssignObserverCurrentProperties","state","getCurrentResult","trackResult","onPropTracked","_this2","trackedResult","Object","keys","forEach","defineProperty","configurable","enumerable","get","trackProp","add","getCurrentQuery","_ref","arguments","length","undefined","assign","_objectDestructuringEmpty","fetch","_objectSpread","fetchOptimistic","_this3","defaultedOptions","then","fetchOptions","_fetchOptions$cancelR","_this4","cancelRefetch","_this5","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","newState","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","_newState","error","errorUpdatedAt","status","select","selectError","placeholderData","_classPrivateFieldGet2","Date","now","isFetching","isPending","isError","isLoading","hasData","isSuccess","isInitialLoading","dataUpdatedAt","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isStale","promise","nextResult","finalizeThenableIfPossible","thenable","resolve","recreateThenable","pending","prevThenable","queryHash","reason","_this6","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","throwOnError","some","typedKey","changed","has","_notify2","onQueryUpdate","catch","_this7","time","timeout","setTimeout","_ref2","refetchInterval","nextInterval","_this8","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","_this9","batch","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","optimisticResult"],"sources":["/Users/JarredCianciulli/Desktop/Applications/Projects/OptimaVita/frontend/node_modules/@tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error('experimental_prefetchInRender feature flag is not enabled'),\n      )\n    }\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key as keyof QueryObserverResult)\n          onPropTracked?.(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Select data if needed\n    if (options.select && newState.data !== undefined) {\n      // Memoize select result\n      if (\n        prevResult &&\n        newState.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(newState.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = newState.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && placeholderData !== undefined) {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}