{"ast":null,"code":"import { color } from '../color/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\nfunction test(v) {\n  var _a, _b;\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\nvar NUMBER_TOKEN = \"number\";\nvar COLOR_TOKEN = \"color\";\nvar VAR_TOKEN = \"var\";\nvar VAR_FUNCTION_TOKEN = \"var(\";\nvar SPLIT_TOKEN = \"${}\";\nvar complexRegex = /(var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))|((-)?([\\d]*\\.?[\\d])+)/gi;\nfunction analyseComplexValue(value) {\n  var originalValue = value.toString();\n  var matchedValues = originalValue.match(complexRegex) || [];\n  var values = [];\n  var indexes = {\n    color: [],\n    number: [],\n    var: []\n  };\n  var types = [];\n  for (var i = 0; i < matchedValues.length; i++) {\n    var parsedValue = matchedValues[i];\n    if (color.test(parsedValue)) {\n      indexes.color.push(i);\n      types.push(COLOR_TOKEN);\n      values.push(color.parse(parsedValue));\n    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n      indexes.var.push(i);\n      types.push(VAR_TOKEN);\n      values.push(parsedValue);\n    } else {\n      indexes.number.push(i);\n      types.push(NUMBER_TOKEN);\n      values.push(parseFloat(parsedValue));\n    }\n  }\n  var tokenised = originalValue.replace(complexRegex, SPLIT_TOKEN);\n  var split = tokenised.split(SPLIT_TOKEN);\n  return {\n    values: values,\n    split: split,\n    indexes: indexes,\n    types: types\n  };\n}\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n  var _analyseComplexValue = analyseComplexValue(source),\n    split = _analyseComplexValue.split,\n    types = _analyseComplexValue.types;\n  var numSections = split.length;\n  return function (v) {\n    var output = \"\";\n    for (var i = 0; i < numSections; i++) {\n      output += split[i];\n      if (v[i] !== undefined) {\n        var type = types[i];\n        if (type === NUMBER_TOKEN) {\n          output += sanitize(v[i]);\n        } else if (type === COLOR_TOKEN) {\n          output += color.transform(v[i]);\n        } else {\n          output += v[i];\n        }\n      }\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = function convertNumbersToZero(v) {\n  return typeof v === \"number\" ? 0 : v;\n};\nfunction getAnimatableNone(v) {\n  var parsed = parseComplexValue(v);\n  var transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = {\n  test: test,\n  parse: parseComplexValue,\n  createTransformer: createTransformer,\n  getAnimatableNone: getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"names":["color","isString","floatRegex","colorRegex","sanitize","test","v","_a","_b","isNaN","match","length","NUMBER_TOKEN","COLOR_TOKEN","VAR_TOKEN","VAR_FUNCTION_TOKEN","SPLIT_TOKEN","complexRegex","analyseComplexValue","value","originalValue","toString","matchedValues","values","indexes","number","var","types","i","parsedValue","push","parse","startsWith","parseFloat","tokenised","replace","split","parseComplexValue","createTransformer","source","_analyseComplexValue","numSections","output","undefined","type","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","map","complex"],"sources":["/Users/JarredCianciulli/Desktop/Applications/Projects/ChooseYouCoaching/frontend/node_modules/framer-motion/dist/es/value/types/complex/index.mjs"],"sourcesContent":["import { color } from '../color/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\nconst complexRegex = /(var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))|((-)?([\\d]*\\.?[\\d])+)/gi;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const matchedValues = originalValue.match(complexRegex) || [];\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    for (let i = 0; i < matchedValues.length; i++) {\n        const parsedValue = matchedValues[i];\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n    }\n    const tokenised = originalValue.replace(complexRegex, SPLIT_TOKEN);\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}